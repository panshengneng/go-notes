#### 10.10 并发的退出

gopl

有时候我们需要通知goroutine停止它正在干的事情，比如一个正在执行计算的web服务，然

而它的客户端已经断开了和服务端的连接。

Go语言并没有提供在一个goroutine中终止另一个goroutine的方法，由于这样会导致goroutine之间的共享变量落在未定义的状态上。在8.7节中的rocket launch程序中，我们往名字叫abort的channel里发送了一个简单的值，在countdown的goroutine中会把这个值理解为自己的退出 信号。但是如果我们想要退出两个或者任意多个goroutine怎么办呢?

一种可能的手段是向abort的channel里发送和goroutine数目一样多的事件来退出它们。如果 这些goroutine中已经有一些自己退出了，那么会导致我们的channel里的事件数比goroutine还 多，这样导致我们的发送直接被阻塞。另一方面，如果这些goroutine又生成了其它的goroutine，我们的channel里的数目又太少了，所以有些goroutine可能会无法接收到退出消 息。一般情况下我们是很难知道在某一个时刻具体有多少个goroutine在运行着的。另外，当 一个goroutine从abort channel中接收到一个值的时候，他会消费掉这个值，这样其它的goroutine就没法看到这条信息。为了能够达到我们退出goroutine的目的，我们需要更靠谱的 策略，来通过一个channel把消息广播出去，这样goroutine们能够看到这条事件消息，并且在 事件完成之后，可以知道这件事已经发生过了。

回忆一下我们关闭了一个channel并且被消费掉了所有已发送的值，操作channel之后的代码 可以立即被执行，并且会产生零值。我们可以将这个机制扩展一下，来作为我们的广播机 制:不要向channel发送值，而是用关闭一个channel来进行广播。

只要一些小修改，我们就可以把退出逻辑加入到前一节的du程序。首先，我们创建一个退出 的channel，这个channel不会向其中发送任何值，但其所在的闭包内要写明程序需要退出。 我们同时还定义了一个工具函数，cancelled，这个函数在被调用的时候会轮询退出状态。



