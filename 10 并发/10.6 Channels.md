### 10.6 Channels

如果说goroutine是Go语言程序的并发体的话，那么channels则是它们之间的通信机制。一个channel是一个通信机制，它可以让一个goroutine通过它给另一个goroutine发送值信息。每个channel都有一个特殊的类型，也就是channels可发送数据的类型。一个可以发送int类型数据 的channel一般写为chan int。

使用内置的make函数，我们可以创建一个channel:

```go
 ch := make(chan int) // ch has type 'chan int'
```

和map类似，channel也对应一个make创建的底层数据结构的引用。当我们复制一个channel或用于函数参数传递时，我们只是拷贝了一个channel引用，因此调用者和被调用者将引用同 一个channel对象。和其它的引用类型一样，channel的零值也是nil。

两个相同类型的channel可以使用==运算符比较。如果两个channel引用的是相同的对象，那 么比较的结果为真。一个channel也可以和nil进行比较。

一个channel有发送和接受两个主要操作，都是通信行为。一个发送语句将一个值从一个goroutine通过channel发送到另一个执行接收操作的goroutine。发送和接收两个操作都使  
 用&lt;-运算符。在发送语句中，&lt;-运算符分割channel和要发送的值。在接收语句中，&lt;-运 算符写在channel对象之前。一个不使用接收结果的接收操作也是合法的。

```
ch <- x  // a send statement
x = <-ch // a receive expression in an assignment statement
<-ch     // a receive statement; result is discarded
```

Channel还支持close操作，用于关闭channel，随后对基于该channel的任何发送操作都将导致panic异常。对一个已经被close过的channel进行接收操作依然可以接受到之前已经成功发送的数据；如果channel中已经没有数据的话将产生一个零值的数据。

使用内置的close函数就可以关闭一个channel：

```go
close(ch)
```

以最简单方式调用make函数创建的是一个无缓存的channel，但是我们也可以指定第二个整型参数，对应channel的容量。如果channel的容量大于零，那么该channel就是带缓存的channel。

```go
ch = make(chan int)    // unbuffered channel
ch = make(chan int, 0) // unbuffered channel
ch = make(chan int, 3) // buffered channel with capacity 3
```

我们将先讨论无缓存的channel，然后在10.6.4节讨论带缓存的channel。

#### 10.6.1 不带缓存的Channels

gopl

一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相 同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以 继续执行后面的语句。反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有 另一个goroutine在相同的Channels上执行发送操作。

基于无缓存Channels的发送和接收操作将导致两个goroutine做一次同步操作。因为这个原 因，无缓存Channels有时候也被称为同步Channels。当通过一个无缓存Channels发送数据 时，接收者收到数据发生在唤醒发送者goroutine之前\(译注:happens before，这是Go语言 并发内存模型的一个关键术语!\)。

在讨论并发编程时，当我们说x事件在y事件之前发生\(happens before\)，我们并不是说x事 件在时间上比y时间更早;我们要表达的意思是要保证在此之前的事件都已经完成了，例如在 此之前的更新某些变量的操作已经完成，你可以放心依赖这些已完成的事件了。

当我们说x事件既不是在y事件之前发生也不是在y事件之后发生，我们就说x事件和y事件是并 发的。这并不是意味着x事件和y事件就一定是同时发生的，我们只是不能确定这两个事件发 生的先后顺序。在下一章中我们将看到，当两个goroutine并发访问了相同的变量时，我们有 必要保证某些事件的执行顺序，以避免出现某些并发问题。

在10.3节的客户端程序，它在主goroutine中\(译注:就是执行main函数的goroutine\)将标准输 入复制到server，因此当客户端程序关闭标准输入时，后台goroutine可能依然在工作。我们 需要让主goroutine等待后台goroutine完成工作后再退出，我们使用了一个channel来同步两个goroutine:

#### 10.6.2 串联的Channels（Pipeline）

#### 10.6.3 单方向的Channel

#### 10.6.4 带缓存的Channels



